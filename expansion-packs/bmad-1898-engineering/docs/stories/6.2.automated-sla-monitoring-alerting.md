# Story 6.2: Automated SLA Monitoring & Alerting

## Status

- **Epic:** Epic 6 - Observability & Optimization Enhancements
- **Status:** Draft
- **Story Points:** 5
- **Priority:** High
- **Created:** 2025-11-08
- **Assigned To:** TBD

## Story

**As a** Security Manager or Security Operations Lead
**I want** automated SLA monitoring with proactive alerting for approaching and violated SLAs
**So that** I can take corrective action before SLA breaches occur and maintain compliance with our security response commitments

## Context

Story 5.9 documented SLA compliance tracking methods and provided the logic for SLA violation detection (lines 1023-1073), but this logic was only provided as reference code, not as an executable script. Currently, SLA monitoring is manual, requiring security managers to periodically check JIRA for overdue tickets. This creates risk of P1/P2 violations going unnoticed until it's too late.

This story implements a production-ready SLA monitoring script with multi-channel alerting (email, Slack) that runs on a schedule to provide continuous compliance oversight.

**References:**
- Story 5.9 (Metrics Documentation) - Lines 1023-1073: SLA monitoring logic and alert thresholds
- Story 5.9 (Metrics Documentation) - Lines 947-964: SLA definitions by priority (P1: 24h, P2: 7d, etc.)
- Story 3.3 (Vulnerability Lifecycle Workflow) - Ticket status transitions

## Acceptance Criteria

- [ ] `scripts/sla_monitor.py` script queries JIRA for open tickets with enrichment completion dates
- [ ] SLA calculations accurate for all priorities (P1-P5) using defined business rules
- [ ] Violations detected when tickets exceed SLA thresholds
- [ ] Warnings triggered when tickets reach 75% of SLA threshold (approaching SLA)
- [ ] Email alerts sent for critical violations (P1 >24h, P2 >7d)
- [ ] Slack notifications sent for warnings (P1 >18h, P2 >5d)
- [ ] Daily digest report sent via email with all P3/P4 tickets approaching SLA
- [ ] Configuration in `config.yaml` for alert thresholds, channels, recipients
- [ ] Script runs on schedule (cron/systemd timer) without manual intervention
- [ ] Dry-run mode for testing without sending alerts
- [ ] Alert deduplication prevents spam (only alert once per ticket per severity level)
- [ ] Documentation includes setup guide, configuration reference, troubleshooting

## Tasks/Subtasks

### Task 1: Implement SLA Calculation Engine

- [ ] Create `workflows/sla_calculator.py` module
- [ ] Implement `calculate_sla_status(ticket, priority, sla_hours)` function
  - Extract enrichment_date from JIRA custom field
  - Calculate age in hours (now - enrichment_date)
  - Determine remaining hours until SLA breach
  - Return status: COMPLIANT | WARNING | VIOLATED
- [ ] Handle business hours vs calendar hours (P1/P2: calendar, P3/P4/P5: business)
- [ ] Account for holidays and weekends in business hours calculation
- [ ] Add unit tests for edge cases (weekends, holidays, timezone handling)

### Task 2: Implement JIRA Query and Data Extraction

- [ ] Use Atlassian MCP to query open tickets
  - JQL: `project = AOD AND status IN ("Enriched", "In Review", "In Remediation") AND enrichment_date IS NOT EMPTY`
- [ ] Extract required fields per ticket:
  - ticket_id, priority, enrichment_date, status, assignee, CVE_id
- [ ] Handle pagination for large result sets (>100 tickets)
- [ ] Implement caching to avoid re-querying within same run
- [ ] Error handling for JIRA API failures (retry logic, fallback)

### Task 3: Implement Multi-Channel Alerting

- [ ] **Email Alerts:**
  - Create `workflows/email_alerter.py`
  - SMTP integration with TLS
  - Template-based emails (critical, warning, digest)
  - Support for multiple recipients from config
  - HTML formatting with color-coded priorities

- [ ] **Slack Alerts:**
  - Create `workflows/slack_alerter.py`
  - Webhook integration
  - Rich message formatting with ticket links
  - Channel routing based on severity
  - Rate limiting to prevent webhook throttling

- [ ] **Alert Templates:**
  - `templates/sla-alert-critical.html` (P1/P2 violations)
  - `templates/sla-alert-warning.html` (approaching SLA)
  - `templates/sla-daily-digest.html` (P3/P4 summary)

### Task 4: Implement Alert Deduplication

- [ ] Create `metrics/sla-alerts.log` to track sent alerts
- [ ] Schema: `timestamp|ticket_id|severity|channel|recipient`
- [ ] Check log before sending alert
- [ ] Only re-alert if severity level increases (WARNING â†’ VIOLATED)
- [ ] Clear alert log when ticket status changes to "Closed" or "Resolved"
- [ ] Implement log rotation (archive after 90 days)

### Task 5: Create Main SLA Monitor Script

- [ ] Create `scripts/sla_monitor.py` CLI script
- [ ] Command-line arguments:
  - `--dry-run`: Print alerts without sending
  - `--priority`: Filter by priority (P1, P2, etc.)
  - `--config`: Override default config file path
  - `--verbose`: Detailed logging output
- [ ] Orchestrate: query JIRA â†’ calculate SLA â†’ send alerts â†’ log results
- [ ] Generate execution summary (tickets checked, violations found, alerts sent)
- [ ] Error handling and logging to `logs/sla-monitor.log`

### Task 6: Configuration and Deployment

- [ ] Add SLA monitoring config section to `config.yaml`:
  ```yaml
  sla_monitoring:
    enabled: true
    alert_thresholds:
      P1: {sla_hours: 24, warning_threshold: 0.75}
      P2: {sla_hours: 168, warning_threshold: 0.71}  # 5 days / 7 days
      P3: {sla_hours: 720, warning_threshold: 0.80}  # 24 days / 30 days
      P4: {sla_hours: 2160, warning_threshold: 0.80}
    email:
      enabled: true
      smtp_server: smtp.gmail.com
      smtp_port: 587
      from_address: sla-monitor@example.com
      recipients:
        critical: [security-manager@example.com, security-lead@example.com]
        warning: [security-manager@example.com]
        digest: [security-team@example.com]
    slack:
      enabled: true
      webhook_url: https://hooks.slack.com/services/YOUR/WEBHOOK/URL
      channels:
        critical: "#security-alerts"
        warning: "#security-ops"
  ```
- [ ] Create systemd timer or cron job for scheduled execution
  - Hourly for P1/P2 monitoring
  - Daily at 9 AM for P3/P4 digest
- [ ] Add script to PATH or create wrapper in project root

### Task 7: Documentation and Testing

- [ ] Create `docs/sla-monitoring-setup.md`:
  - Prerequisites (JIRA access, SMTP/Slack credentials)
  - Configuration guide
  - Deployment instructions (cron/systemd)
  - Troubleshooting common issues
- [ ] Update Story 5.9 to reference implemented script
- [ ] Create test scenarios with mock JIRA data
- [ ] Validate alert templates render correctly
- [ ] Test dry-run mode end-to-end

## Technical Approach

### SLA Calculation with Business Hours

**Calendar Hours (P1, P2):**
```python
from datetime import datetime

def calculate_calendar_hours_sla(enrichment_date, sla_hours):
    """Simple calendar hour calculation for P1/P2"""
    now = datetime.utcnow()
    age_hours = (now - enrichment_date).total_seconds() / 3600
    remaining_hours = sla_hours - age_hours

    if remaining_hours < 0:
        return 'VIOLATED', abs(remaining_hours)
    elif remaining_hours < sla_hours * 0.25:  # Within last 25%
        return 'WARNING', remaining_hours
    else:
        return 'COMPLIANT', remaining_hours
```

**Business Hours (P3, P4, P5):**
```python
def calculate_business_hours_sla(enrichment_date, sla_hours, holiday_calendar):
    """
    Business hours calculation excluding weekends and holidays

    Args:
        enrichment_date: Timestamp when enrichment completed
        sla_hours: SLA target in business hours
        holiday_calendar: List of holiday dates to exclude

    Returns:
        tuple: (status, remaining_hours)
    """
    from dateutil import rrule

    # Count business hours between enrichment_date and now
    business_hours_elapsed = 0
    current = enrichment_date
    now = datetime.utcnow()

    while current < now:
        # Skip weekends
        if current.weekday() < 5:  # Monday=0, Friday=4
            # Skip holidays
            if current.date() not in holiday_calendar:
                # Count only business hours (9 AM - 5 PM = 8 hours)
                if 9 <= current.hour < 17:
                    business_hours_elapsed += 1

        current += timedelta(hours=1)

    remaining_hours = sla_hours - business_hours_elapsed

    if remaining_hours < 0:
        return 'VIOLATED', abs(remaining_hours)
    elif remaining_hours < sla_hours * 0.20:  # Within last 20%
        return 'WARNING', remaining_hours
    else:
        return 'COMPLIANT', remaining_hours
```

### Alert Template Example

**templates/sla-alert-critical.html:**
```html
<!DOCTYPE html>
<html>
<head>
    <style>
        body { font-family: Arial, sans-serif; }
        .alert-box { border: 3px solid #d32f2f; padding: 20px; background-color: #ffebee; }
        .ticket-id { font-size: 20px; font-weight: bold; color: #d32f2f; }
        .details { margin-top: 15px; }
        .detail-row { margin: 5px 0; }
        .action-items { background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 10px; margin-top: 20px; }
    </style>
</head>
<body>
    <div class="alert-box">
        <h2>ðŸš¨ SLA VIOLATION ALERT</h2>
        <div class="ticket-id">{{ticket_id}}: {{cve_id}}</div>

        <div class="details">
            <div class="detail-row"><strong>Priority:</strong> {{priority}}</div>
            <div class="detail-row"><strong>SLA Target:</strong> {{sla_target}}</div>
            <div class="detail-row"><strong>Current Age:</strong> {{current_age}}</div>
            <div class="detail-row"><strong>Overdue By:</strong> {{overdue_by}}</div>
            <div class="detail-row"><strong>Status:</strong> {{status}}</div>
            <div class="detail-row"><strong>Assignee:</strong> {{assignee}}</div>
            <div class="detail-row"><strong>Enriched On:</strong> {{enrichment_date}}</div>
        </div>

        <div class="action-items">
            <h3>Required Actions:</h3>
            <ul>
                <li>Review ticket status and blockers immediately</li>
                <li>Escalate to {{escalation_contact}} if blocked</li>
                <li>Update JIRA with status comment</li>
            </ul>
        </div>

        <p><a href="{{jira_url}}">Open Ticket in JIRA â†’</a></p>
    </div>
</body>
</html>
```

### Systemd Timer Configuration

**`/etc/systemd/system/sla-monitor.timer`:**
```ini
[Unit]
Description=SLA Monitor Hourly Check
Requires=sla-monitor.service

[Timer]
OnCalendar=hourly
Persistent=true

[Install]
WantedBy=timers.target
```

**`/etc/systemd/system/sla-monitor.service`:**
```ini
[Unit]
Description=Check SLA compliance for security tickets
After=network.target

[Service]
Type=oneshot
User=security-ops
WorkingDirectory=/opt/bmad-1898-engineering
ExecStart=/usr/bin/python3 scripts/sla_monitor.py --config config.yaml
StandardOutput=journal
StandardError=journal
```

**Enable and start:**
```bash
sudo systemctl enable sla-monitor.timer
sudo systemctl start sla-monitor.timer
sudo systemctl status sla-monitor.timer
```

### Alert Deduplication Logic

```python
def should_send_alert(ticket_id, severity, alert_log_path):
    """
    Check if alert should be sent based on deduplication log

    Args:
        ticket_id: JIRA ticket ID
        severity: VIOLATED or WARNING
        alert_log_path: Path to sla-alerts.log

    Returns:
        bool: True if alert should be sent
    """
    if not os.path.exists(alert_log_path):
        return True  # First alert, always send

    # Read recent alerts for this ticket
    with open(alert_log_path, 'r') as f:
        lines = f.readlines()

    # Parse last 100 lines (performance optimization)
    recent_alerts = [line.strip().split('|') for line in lines[-100:]]

    # Check if we've already alerted for this ticket at this severity level
    for alert in recent_alerts:
        if len(alert) >= 3:
            alerted_ticket_id = alert[1]
            alerted_severity = alert[2]

            if alerted_ticket_id == ticket_id:
                if alerted_severity == 'VIOLATED':
                    # Already sent VIOLATED alert, don't re-send
                    return False
                elif alerted_severity == 'WARNING' and severity == 'WARNING':
                    # Already sent WARNING, don't re-send
                    return False
                elif alerted_severity == 'WARNING' and severity == 'VIOLATED':
                    # Escalation: WARNING â†’ VIOLATED, send new alert
                    return True

    return True  # No matching alert found, send it
```

## Integration Points

**Story 5.9 (Metrics Documentation):**
- Update "Future Enhancement" to reference this implemented script
- Add execution examples to documentation
- Include sample alert outputs

**Story 3.3 (Lifecycle Workflow):**
- SLA monitor queries tickets in lifecycle states
- Enrichment completion date is the SLA start event

**Story 3.4 (Review Triggering):**
- P1/P2 mandatory reviews impact SLA (review time counts toward SLA)

**Atlassian MCP:**
- JIRA query for open tickets
- Extract enrichment_date custom field
- Get ticket details (priority, assignee, status)

## Definition of Done

- [ ] `scripts/sla_monitor.py` runs successfully in dry-run mode
- [ ] SLA calculations verified accurate for all priorities
- [ ] Email alerts sent to configured recipients for P1/P2 violations
- [ ] Slack notifications posted to correct channels
- [ ] Daily digest generated and sent at 9 AM
- [ ] Alert deduplication prevents duplicate alerts
- [ ] Systemd timer or cron job configured and running
- [ ] Configuration documented in `config.yaml` with all options
- [ ] Setup guide created in `docs/sla-monitoring-setup.md`
- [ ] Test scenarios executed with 100% pass rate
- [ ] Code reviewed and approved by QA
- [ ] All tests passing

## Dependencies

**Depends On:**
- Story 3.1 (Enrichment Workflow) - Enrichment date field populated âœ…
- Story 3.3 (Lifecycle Workflow) - Ticket status transitions defined âœ…
- Story 5.9 (Metrics Documentation) - SLA definitions documented âœ…

**Requires:**
- Atlassian MCP server configured
- SMTP server access for email alerts
- Slack webhook URL for notifications
- JIRA custom field: `enrichment_date` (timestamp)

**Blocks:**
- Advanced SLA analytics and trending (future enhancement)
- Automated escalation workflows (future enhancement)

## Risks and Mitigations

| Risk | Impact | Probability | Mitigation |
| --- | --- | --- | --- |
| Alert fatigue from too many notifications | High | High | Implement deduplication, threshold tuning, digest mode |
| JIRA API rate limiting breaks monitoring | High | Medium | Implement caching, exponential backoff, fallback to cached data |
| Email/Slack failures cause missed alerts | Critical | Medium | Log all intended alerts, retry logic, fallback channels |
| Business hours calculation incorrect for timezones | Medium | Medium | Use UTC for all calculations, document timezone assumptions |
| Script failure goes unnoticed (cron silent failure) | High | Medium | Systemd journal logging, heartbeat monitoring, weekly summary |

## Testing Strategy

**Unit Tests:**
- SLA calculation for each priority (P1-P5)
- Business hours calculation with weekends/holidays
- Alert deduplication logic
- Template rendering

**Integration Tests:**
- JIRA query and field extraction
- Email sending via SMTP
- Slack webhook posting
- Alert log writing

**End-to-End Tests:**
1. **Violation Detection:**
   - Create test ticket with enrichment_date = 30 hours ago, priority = P1
   - Run script, verify VIOLATED alert sent

2. **Warning Detection:**
   - Create test ticket with enrichment_date = 20 hours ago, priority = P1
   - Run script, verify WARNING alert sent

3. **Deduplication:**
   - Run script twice on same violation
   - Verify only one alert sent

4. **Daily Digest:**
   - Create 5 P3 tickets approaching SLA
   - Run script, verify digest email contains all 5

5. **Dry-Run Mode:**
   - Run with `--dry-run` flag
   - Verify no alerts sent, only printed

**Performance Tests:**
- Query 1000+ tickets in reasonable time (<30 seconds)
- Alert generation for 50+ violations (<1 minute)

## Success Metrics

- **Reliability:** 99.9% script execution success rate
- **Timeliness:** P1 violations detected within 1 hour of breach
- **Accuracy:** 100% SLA calculations match manual verification
- **Coverage:** 100% of P1/P2 violations trigger alerts
- **Actionability:** Alert response time <2 hours for critical alerts

## Configuration Example

**config.yaml SLA monitoring section:**
```yaml
sla_monitoring:
  enabled: true

  # SLA definitions (in hours)
  sla_targets:
    P1: 24
    P2: 168   # 7 days
    P3: 720   # 30 days (business hours)
    P4: 2160  # 90 days (business hours)
    P5: null  # Best effort, no SLA

  # Warning thresholds (% of SLA remaining)
  warning_thresholds:
    P1: 0.25  # Alert at 6 hours remaining
    P2: 0.29  # Alert at 2 days remaining
    P3: 0.20  # Alert at 6 days remaining
    P4: 0.20  # Alert at 18 days remaining

  # Alert channels
  email:
    enabled: true
    smtp_server: smtp.gmail.com
    smtp_port: 587
    from_address: sla-monitor@example.com
    use_tls: true
    recipients:
      critical: [security-manager@example.com, on-call@example.com]
      warning: [security-ops@example.com]
      digest: [security-team@example.com]

  slack:
    enabled: true
    webhook_url: ${SLACK_WEBHOOK_URL}  # From environment variable
    channels:
      critical: "#security-critical"
      warning: "#security-ops"
      digest: "#security-daily"
    rate_limit_delay: 1  # Seconds between posts

  # Holiday calendar (exclude from business hours)
  holidays:
    - 2025-01-01  # New Year's Day
    - 2025-12-25  # Christmas
    # Add your organization's holidays

  # Logging and retention
  alert_log: metrics/sla-alerts.log
  execution_log: logs/sla-monitor.log
  retention_days: 90

  # Schedule (for documentation, actual schedule in cron/systemd)
  schedule:
    critical_check: "hourly"
    warning_check: "every 4 hours"
    daily_digest: "daily at 09:00"
```

## CLI Usage Examples

```bash
# Normal execution (send alerts)
python3 scripts/sla_monitor.py

# Dry-run mode (test without sending)
python3 scripts/sla_monitor.py --dry-run

# Monitor only P1/P2 critical priorities
python3 scripts/sla_monitor.py --priority P1 --priority P2

# Verbose logging for troubleshooting
python3 scripts/sla_monitor.py --verbose

# Use alternate config file
python3 scripts/sla_monitor.py --config /path/to/custom-config.yaml

# Generate daily digest only
python3 scripts/sla_monitor.py --digest-only

# Check specific ticket
python3 scripts/sla_monitor.py --ticket AOD-1234
```

## Notes

This story addresses a critical operational gap identified in Story 5.9 QA review. Moving from passive SLA reporting to proactive monitoring and alerting significantly reduces the risk of compliance failures and improves response times.

**Future Enhancements:**
- Integration with PagerDuty for on-call escalation
- Machine learning to predict SLA violations before they occur
- Automated ticket prioritization based on time-to-SLA
- SLA compliance trending dashboard (Grafana)
- Automated escalation workflows (reassign, notify manager, etc.)

## Change Log

| Date | Version | Author | Changes |
| --- | --- | --- | --- |
| 2025-11-08 | 1.0 | Quinn (Test Architect) | Initial story outline created from Story 5.9 review recommendations |
