---
story_id: STORY-009
title: Implement Retrieval Tasks (4 tasks)
epic_id: EPIC-001
phase: 1
priority: high
estimated_effort: 20 hours
status: todo
created: 2025-11-04

user_story: |
  As a developer
  I want to create the retrieval workflow tasks
  So that Query Interpreter Agent can execute multi-source queries

acceptance_criteria:
  - Create tasks/retrieval/ directory
  - Implement parse-natural-language-query.md task
  - Implement execute-obsidian-query.md task
  - Implement execute-neo4j-query.md task (optional, Neo4j)
  - Implement merge-results.md task
  - All tasks follow BMAD task specification format
  - Tasks include query patterns and examples
  - Tasks specify result formats

technical_notes: |
  Task 1: parse-natural-language-query.md
  - Input: Natural language query string
  - Process: Intent classification, entity extraction, query decomposition
  - Output: Structured query object (intent, entities, sub-queries, filters)
  - Intent types: factual, temporal, causal, comparative, exploratory
  - Query decomposition patterns:
    - "How has X evolved?" → temporal intent + entity X + time range filter
    - "Compare X and Y" → comparative intent + entities [X, Y]
    - "Why does X happen?" → causal intent + entity X

  Task 2: execute-obsidian-query.md
  - Input: Structured query object
  - Process: Execute appropriate Obsidian query
  - Output: List of matching notes with metadata
  - Query types:
    - Text search: obsidian.search_notes (text query)
    - Semantic search: smart_connections.semantic_search (embedding query)
    - Tag search: obsidian.search_notes (tag filter)
    - Metadata search: obsidian.search_notes (frontmatter filter)
  - MCP tools: obsidian.search_notes, smart_connections.semantic_search

  Task 3: execute-neo4j-query.md
  - Input: Structured query object
  - Process: Generate and execute Cypher query
  - Output: List of matching nodes/relationships with temporal metadata
  - Query patterns:
    - Temporal: "How has X evolved?" → Query edit history, promotions
    - Causal: "Why X?" → Query [:INFLUENCED] relationships
    - Graph traversal: "Related to X" → Query [:LINKED_TO] relationships
  - MCP tools: graphiti.search_facts, graphiti.query_temporal (optional)

  Task 4: merge-results.md
  - Input: Results from Obsidian + Neo4j (if available)
  - Process: Deduplicate, rank by relevance, identify contradictions
  - Output: Unified result set with source attribution
  - Merging algorithm:
    - Deduplicate by note ID
    - Rank by combined relevance score (Obsidian + Neo4j signals)
    - Detect contradictions (conflicting claims from different notes)
    - Add source attribution (which queries contributed each result)
    - Format based on query intent (narrative, list, table, timeline)

dependencies:
  - STORY-001: Expansion pack infrastructure
  - STORY-005: Query Interpreter Agent (consumer)
  - query-result-tmpl.yaml template
  - query-completeness-checklist.md

testing:
  - Parse factual query: "What is Zettelkasten?"
  - Parse temporal query: "How has my understanding evolved?"
  - Execute Obsidian text search
  - Execute Obsidian semantic search
  - Execute Neo4j temporal query
  - Merge results from multiple sources
  - Detect contradictions in results

definition_of_done:
  - All 4 task files created in tasks/retrieval/
  - Tasks follow BMAD specification format
  - Query patterns documented with examples
  - Result formats specified
  - MCP tool dependencies documented
  - Tasks tested individually and in workflows
  - Documentation added to developer guide
